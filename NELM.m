%Program for approximation of immittance spectra using nonlinear%complex least squares method%Version 1.0 beta%Main programmer, audio effects: Daniil D. Stupin%Coding engineer, graphics:      Natalia A. Boitsova%Beta tester, art designer:      Anna A. Abelit%SPbAU, BioElectronics laboratory%2025 %%%%%%%%%%%%%%%%%%%%%%%%%%%%  Program initialization %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Custom program settings                                         %% From here on you can change any parameters that come after this %% special symbol ---->>>>                                         %%                                                                 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%WelcomeMessage;                                                            %Displaying welcoming messageif ~IsMatLab  For_Octave_compatibility;                                                %Make compatability with GNU Octaveend;%---->>>>Start of the processing modenew=true;                                                                  %Variable "new" is responsible for the necessity of starting processing all measurements again (new=true) or not (new=false).Manual_Batch=false;                                                         %Variable Manual_Batch allow user to hand pick experiments that will be processedif new%---->>>>Specifying folders that posses data names={                                                                   %Creating handy list of folders that are used the most                                                                           %Feel free to add your own path, this ones are just examples     'D:\data'            % 1        [pwd '\Example_data']% 2      }; I_select_folder_number = 2;                                               %In order to choose the default folder, just write its number here%---->>>>Setting files' label  for the results of approximationCNLS_fit_Label  = '\CNLS';%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%               Library of the data-file formats                          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%---->>>> Creating file mask and function with which NELM will extract data file_type(1).file_mask           = 'data*.dat';                           %NELM is able to work with ASCII format, and we recommend using it file_type(1).Loading_Spectrum    = @Get_Spectrum_ascii;                   %In order to use your own format of data, you need to create new mask and new function, using existing ones as your guide. The symbol "*" in mask is used for denoting data-file sequence number. file_type(2).file_mask           = 'data*_AF.dat';                        %File type 2 can be used after AF processing for following CNLS approximation file_type(2).Loading_Spectrum    = @Get_Spectrum_ascii; file_type(3).file_mask           = 'data*.i!';                            %Data format "i!" ("i factorial"), developed in our laboratory file_type(3).Loading_Spectrum    = @Get_FFT_Spectrum; file_type(3).Loading_Time_Domain = @I2mat; file_type(4).file_mask           = 'data*.wav';                           %Sound wav-file for time-domain impedance spectroscopy file_type(4).Loading_Spectrum    = @Get_FFT_Spectrum_from_wav; file_type(4).Loading_Time_Domain = @Get_Time_Domain_Data_from_wav; file_type(5).file_mask           = 'data*.mat';                           %mat-file for frequency-domain impedance spectroscopy file_type(5).Loading_Spectrum    = @Get_Spectrum_mat; file_type(6).file_mask           = 'data*.mat';                           %mat-file for time-domain impedance spectroscopy file_type(6).Loading_Spectrum    = @Get_FFT_Spectrum_from_mat; file_type(6).Loading_Time_Domain = @Get_Time_Domain_Data_from_mat; %---->>>> Choosing file mask and function with which NELM will extract data I_select_file_type_number=4; %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%path file_type=file_type(I_select_file_type_number);                           %Setting file type that was selected Settings_Description  file_mask=file_type.file_mask;                                            %Getting file mask that corresponds to that type extension=strsplit(file_mask,'.');                                        %Getting the extension from the mask extension=char(extension(end)); extension=strrep(extension,'!','*');                                      %Some Windows bug with ! if ~Manual_Batch  path = uigetdir(char(names(I_select_folder_number)),...                  %Opening dialog with default folder that was set on the 39 line     'Hi, dear user! What experiment would you like me to process?');  if path==0   disp('See you later!')   return;  end;  file_names=Prepare_files_list(path, file_mask, 'date' );                 %Using user chosen path and file mask, making list of the files in need of approximation  if isempty(file_names)                                                   %'dpathate' corresponds to sorting by the time of creation, 'mask' to sorting by numbers that follow the mask      return;  end; else                                                                      %Choosing files in case of Manual_Batch  [file_names, path] =  uigetfile({['*.', extension]}, ...   'Hi, dear user! What experiment would you like me to process?', ...   char(names(I_select_folder_number)), 'MultiSelect','on');  file_names=file_names';  if path==0      disp('See you later!')      return;  end;  path=path(1:end-1);                                                      %Deleting last "\" in the path end;if iscell(file_names)                                                      %Getting number of files    [N_files, ~]=size(file_names);else    N_files=1;end; for j=1:N_files                                                           %Creating list of files with their specific places     if iscell(file_names)      file_names{j}=[path '\' file_names{j}];     else      file_names=[path '\' file_names'];     end; end;save('SysTemp.mat', 'file_names','Manual_Batch','path','file_type',...                                                        'CNLS_fit_Label'); %Saving the essential variables to the buffer mat-file and getting rid of excess variablesclear all; load('SysTemp.mat'); delete SysTemp.mat;new=true;                                                                  %'Remembering' that new is trueend;Version=1.0;                                                               %Setting NELM version to ensure compatibility%---->>>> To disable the dialog box about loading CNLS autosave files, you can%comment out the following lineif new                                                                     %Calling a script that checks whether or not approximation results exist for this experiment Check_Fotrune_for_continue;                                               %and, if they exist, offers the user to load themend;                                                                       %and continue processing the data from the experiment number where these results were saved%---->>>> Turn sound on/offIsMute=false;%---->>>> Enable/disable visual check of approximation quality%after "warming-up" modeSkipVisual=false;%---->>>>Enable/disable loading of approximation parameters using the GUIGUI_Settings_Load=true;%---->>>> Enable/disable graph rendering during approximationPlot_Graphs=true;%---->>>> Half-period for autosave                                         %The program will autosave every 2*AutoSaveHalfPeriod iterationsAutoSaveHalfPeriod=5;                                                      %(half period is used here because since two "synchronous" channels are processed,                                                                           % it makes sense to save after an even number of iterations, when both channels are processed the same number of times).%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                          %%---->>>> Loading approximation parameters %%                                          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if new    if GUI_Settings_Load&&IsMatLab        ok_=false;        waitfor(Selecting_Settings_GUI, 'UserData');                       %Waiting for user input        if length(dir('Settings.mat'))~=0 && ok_                           %Getting data from settings            load('Settings.mat');            delete Settings.mat;            clear ok_;            if exist('Setting_Load_Error')                disp(Setting_Load_Error);                return;            end;        else            disp('See you later!')            return;        end;    else        Settings_Example_RL_CPE_NM;                                        %If GNU Octave is used or if GUI is disabled then load Settings_*.m file manually    end;Get_Spectrum_Func=file_type.Loading_Spectrum;                              %Setting up function for reading immittance spectra from files, which contain experimental dataif isfield(file_type,'Loading_Time_Domain')    Get_Time_Domain_Data=file_type.Loading_Time_Domain;else    Get_Time_Domain_Data=[];end;end;%%%%%%%%%%%%%%%%%%%%%%%%% Preparing the program %%%%%%%%%%%%%%%%%%%%%%%%%Channels_initialization;                                                   %Initializing an array of structures to store data from different channels.close all;                                                                 %Closing all windows and files and clearing the consoleF_=findall(0,'type','figure'); delete(F_); clear F_;                       %Closing all graphsfclose all;clc;tic                                                                        %Starting timerProgress=0;                                                                %Initializing the variable responsible for monitoring the progress of data processingif new                                                                     %If processing the data again, starting from the first meausurement    Start=Start_From;    if Manual_Batch                                                        %In case of Manual Batch some extra variables are additionally set        Start_From=0;        Ch_Num=1;    end;else    Start=exp_num;                                                         %if not -- then continuing processing data from the number where the program was stopped earlyend;[R_, ~]=size(file_names);if R_~=1    if Finish_At==Inf||Finish_At>R_        Finish=R_;                                                         %Setting the number of spectra to process    else        Finish=Finish_At;    end;else    Finish=Start;end;clear R_;if new                                                                     %Set an additional variable to monitor the processing progress if Manual_Batch    Total=Finish-Start+1; else    Total=Finish-Start; end end;if new Time=[];end;hwb = waitbar(0, 'Program started...', 'Name',...                          %Create a ProgressBar to monitor the approximation process                   'CNLS fitting','CreateCancelBtn','delete(gcbf)');soft_stop=false;                                                           %Create a logical variable in case of soft loop terminationBackUpMode=false;Message=[];P_CNLS=0.999;                                                              %Probability-value for Jacobian based confidence intervals calculationP_MC=0.95;                                                                 %Probability-value for Monte-Carlo based confidence intervals calculation%%%%%%%%%%%%%%%%%%%%%%%%%%%% The main program loop   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Start of the main program loop  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for exp_num=Start:Finish  Ch=mod(exp_num-1, Ch_Num)+1;  if Is_Warming_Up                                                         %<--- If the warm-up mode is on, then...   options.MaxIter=MaxIter*WUC;                                            %Setting an increased iteration value for warming up   options.MaxFunEvals = MaxFuncEvals*WUC;   disp(['Warming up channel ' num2str(Ch) '...']);                        %Displaying information about start of warming up   Model=Channels(Ch).Model;                                               %Getting model   Model_Options=Channels(Ch).Model_Options;                               %Getting model options   x0_seed=Channels(Ch).x0_init;                                           %Getting starting point  else                                                                     % If the warm-up mode is not enabled, then...    if isfield(options,'UseSingleN')                                       %Checking if user chose non paralell mode     if options.UseSingleN      N=1;     end;    end;    options.MaxIter=MaxIter;                                               %Setting a number of iterations    options.MaxFunEvals = MaxFuncEvals;    Model=Channels(Ch).Model;                                              %Getting model    Model_Options=Channels(Ch).Model_Options;                              %Getting model options    if isempty(Channels(Ch).Best)     x0_seed=Channels(Ch).x0_init;                                         %Setting starting point in case if warming up is turned off    else        if ~isfield(options,'causal')            options.causal=true;        end;        if options.causal            x0_seed=Channels(Ch).Best(end,1:end-2);                        %Setting starting point as a result of a previous step        else            x0_seed=Channels(Ch).x0_init;                                  %Setting starting point as a universial starting point        end;    end;  end;  Model_Options.Is_Warming_Up=Is_Warming_Up;  Check_vars_and_set_default;                                              %Ensuring compatibility between different versions  misc.Ch_Num=Ch_Num;  if chk_vars_error_      return;  else    clear  chk_vars_error_;  end;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Statistical loop that uses parallel computing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% InLoop=true;                                                              %The InLoop variable is used for restarting parallel loop if it  has ended with errors. while InLoop  try   parfor Stat_exp_num=1:N                                                    %In order to not use parallel computation parfor needs to be replaced with for    x0=0;    if Stat_exp_num==1        x0=x0_seed;                                                        %First experiment starts from the setted by user starting point without changes    else     switch options.Monte_Carlo_Mode       case 'local'             x0=x0_seed.*(1+(rand(1,length(x0_seed))-0.5) ...                 *2*options.rand_Amp);                                     %Setting a random location of the initial approximation in some neighborhood of the approximation result obtained from the previous! experiment       case 'global'             x0= Channels(Ch).x0_space_origin.*(1+(rand(1,...            length(Channels(Ch).x0_space_origin))-0.5)*2*options.rand_Amp);%Setting a random location of the initial approximation in some neighborhood of the universal point         otherwise             error('=( Unknown Monte-Carlo Mode type');      end;    end;   [Result_Stat(Stat_exp_num,:), infos(Stat_exp_num),flag(Stat_exp_num),...%Calling the NELM_Func function, which directly performs the spectra approximation. The approximation result is written to Result_Stat array   Time_(Stat_exp_num), Misc(Stat_exp_num)]=...                             %simultaneously saving the approximation process exit flags (flag), system messages about it (infos) and the measurement time    NELM_Func(file_names, exp_num, Stat_exp_num,  x0, Get_Spectrum_Func, ...%in seconds from the OS startup. Also, in the Result_Stat array, in the last column,    Get_Time_Domain_Data, Model, Model_Options,W_Type, options, misc);                           %the discrepancy between the experiment and the approximation is written.   end;   InLoop=false;                                                           %If the parallel loop has completed without errors, then assigning the value false to the InLoop variable and exiting the while loop.  catch Message                                                            %If errors occur in the parallel loop, the code immediately transfers program execution to this line ("try" enviropment).   clc;   if strcmp(Message.message,...                                           %If in the Message variable, which stores information about the error that occurred,    'Invalid file identifier. Use fopen to generate a valid file identifier.')%it is written that the program could not open the input file with spectra, then    disp('Connection lost. Please, check or restat your network. Reconnecting...'); %reporting the most probable cause of the error (i.e. say that the network drive has disconnected)    disp('(You can also press Cancel button on the Progress Bar for stop processing and save current CNLS data in back up mat-file)')   else    disp('Unexpected error:') ;                                            %If something else happened, informing the user about it.    disp(Message.message);    disp('Trying again... (you can press Cancel button on the Progress Bar for stop processing and save current CNLS data in back up mat-file)')   end;   pause(0.1);                                                             %Pausing to allow clicking the Cancel button on the ProgressBar.   if ~ishandle(hwb)                                                       %After pressing the Cancel button on the "progress bar", the window handle will disappear, which will lead to an exit from the loop.    InLoop=false;                                                          %Exiting the protective while loop    BackUpMode=true;                                                       %Putting the script into emergency autosave mode    soft_stop=true;                                                        %Switching the script to "soft" termination mode   end;  end; end;  if BackUpMode     break;                                                                %Exiting the main program loop end; [~, I]=min(Result_Stat(:,end));                                           %If catch does not executed (no error detected), then finding the best approximation from N parallel statistical experiments%Change>>>>> Result_Stat(:,Channels(Ch).Model_Options.non_negative_pars)=...                     abs(Result_Stat(:,Channels(Ch).Model_Options.non_negative_pars)); Channels(Ch).Best=[Channels(Ch).Best;                    Result_Stat(I,:), flag(I)];                            %Saving the best result and the corresponding flag [~, ~, f, ~, ~]=Get_Spectrum_Func(file_names, exp_num, options);       %Stub for getting f for experimental points counting Channels(Ch).Best_CI=[Channels(Ch).Best_CI; Get_CNLS_stat(...               %Evaluating and saving the confidence intervals                       Channels(Ch).Model, f, Result_Stat(I,1:end-1),...                       Channels(Ch).Model_Options, Result_Stat(I,end),...                                                                P_CNLS)']; Channels(Ch).infos_Best=[Channels(Ch).infos_Best infos(I)]; Channels(Ch).Time=[Channels(Ch).Time Time_(1)]; Channels(Ch).exp_nums=[Channels(Ch).exp_nums exp_num]; [Mean_ CI_]=Get_Stat_Func([Result_Stat flag'].' ,P_MC);                   %Getting statistics Channels(Ch).Mean=[Channels(Ch).Mean; Mean_]; Channels(Ch).CI=[Channels(Ch).CI; CI_]; Channels(Ch).Misc=[Channels(Ch).Misc; Misc(I)]; clc; disp(strcat('Progress:',{' '},num2str(round((exp_num-Start_From)/Total*100)),...       %Outputing the progress to the console              '% exp_num=', num2str(exp_num))); if mod(exp_num,AutoSaveHalfPeriod*2)==0&&exp_num>1                        %Saving at each AutoSaveHalfPeriod*2 measurement     close(hwb);     save(strcat(path,'\CNLS_Stat_AutoSave.mat'));     hwb = waitbar(exp_num/Total, 'Progress', 'Name',...                   'CNLS fitting','CreateCancelBtn','delete(gcbf)');     waitbar(exp_num/Total,hwb, [num2str(round((exp_num-Start_From)/Total*100))...             '% (exp\_num ' num2str(exp_num) ' from ' num2str(Total) ')']); end; %%%Part for transition from warming-up mode to normal calculations %%%%%%    if Ch==Ch_Num&&Is_Warming_Up   Is_Warming_Up=false;                                                    %End of warm-up mode   %Visual control of approximation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   if ~SkipVisual    Alarm('',IsMute);                                                      %Sounding the alarm    disp('After warming-up stage I have found these parameters values:')    Show_pars_in_console(Channels,1);     h_=figure('Name',...      '>>>>>>> Please, check the graphs and press any key if they are ok <<<<<<<');     for j=1:Ch_Num      subplot(1,Ch_Num,j);      Plot_Check_Func(file_names, Channels(j).exp_nums(1), Get_Spectrum_Func,  Channels(j).Model, Channels(j).Best(1,1:end-2), ...                     Channels(j).Model_Options,options, Version);                   %Making graphs Experiment vs. Approximation for a channel     end;     disp('Please, check the graphs and press any key if they are ok');     Scr_=get(0, 'Screensize');                                            %Maximize the graph window     set(gcf, 'Position', [Scr_(1)+100 Scr_(2)+100 Scr_(3)-200 Scr_(4)-200]);     pause;                                                                %Waiting for a key to be pressed     close (h_);clear h_ Scr_;     disp('Warming up mode is switched off. Starting processing all data...')   end;   % Fixing parameters after warming up   for j=1:Ch_Num      [Channels(j).WA_Best, ...       Channels(j).WA_Best_CI,...       Channels(j).WA_Mean, ...       Channels(j).WA_CI]=Get_full_pars_from_Channel(Channels(j));      %Reconstructing all parameters from the Best fileld and fix_pars field       Channels(j).Model_Options.fix_pars=[Channels(j).Model_Options.pars_to_be_fixed;                   Channels(j).WA_Best(Channels(j).Model_Options.pars_to_be_fixed)]; %Updating the fix_pars field with the data, obtained during warming-up mode       extra_Best = Channels(j).Best(:,end-1:end);                      %Extracting the additional, non-parameters data from channels       extra_Mean = Channels(j).Mean(:,end-1:end);       extra_CI   = Channels(j).CI(:,end-1:end);       Info_=Channels(j).Model(Channels(j).Model_Options);              %Loading Model information with the updated fix_pars field       if ~isfield(Info_,'non_fix_pars_idx')            Info_.non_fix_pars_idx = Non_fix_pars_idx( Channels(j), false );       end;       Channels(j).Best =...                                            % Assembling the Best fileld with the updated fix_pars field              [Channels(j).WA_Best(:,Info_.non_fix_pars_idx),...                                                 extra_Best];       Channels(j).Best_CI =...                                            % Assembling the Best fileld with the updated fix_pars field              [Channels(j).WA_Best_CI(:,Info_.non_fix_pars_idx)];                 Channels(j).Mean =...              [Channels(j).WA_Mean(:,Info_.non_fix_pars_idx),...                                                 extra_Mean];          Channels(j).CI=...              [Channels(j).WA_CI(:, Info_.non_fix_pars_idx),...                                                    extra_CI];         Channels(j).Model_Options.non_negative_pars=Info_.non_negative_pars;   end;   Result_Stat=[];   flag=[];  end;  %%%End of block transition from warm-up mode to normal counting %%%%%%%%%%%%%% pause(0.01);                                                              %Letting the program rest for 10 ms and check if the Cancell button on the progress bar is pressed. if ~ishandle(hwb)                                                         %After pressing the Cancel button on the "progress bar", the window handle will disappear, which will lead to an exit from the loop.  soft_stop=true;  break; else  waitbar((exp_num-Start_From)/Total,hwb, [num2str(floor((exp_num-Start_From)/Total*100))...             '% (exp\_num ' num2str(exp_num) ' from ' num2str(Finish) ')']); %Otherwise displaying the progress end; if ~isempty(Channels(end).Best)    if Plot_Graphs     if length(Channels(1).Best(:,1))==1                                   %After processing the first spectra for all channels, creating a graph window and assigning it a caption in the title.      figure('Name', 'CNLS fit results');     end;     [Y_exp, Time, f, W, V_os]=Get_Spectrum_Func(file_names, exp_num, options);     Y_m=Channels(Ch).Model(f, Channels(Ch).Best(end, 1:end-2), Channels(Ch).Model_Options);     Plot_immittance_multi_data(f, Y_exp, Y_m, options);     Channels(Ch).Y_exp=[Channels(Ch).Y_exp Y_exp(:)];                     %For debugF     Channels(Ch).Y_m=[Channels(Ch).Y_m Y_m(:)];                           %For debug        if length(Y_exp)==length(Y_m)         title(['Residual ' num2str(Channels(Ch).Best(end, end-1))])     end;    end; end;% keyboard;                                                                % useful command for debugend;%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Finishing program's work %%%%%%%%%%%%%%%%%%%%%%%%%%%%%Parallel_time=toc;                                                         %Determining the time spent on data processingif BackUpMode    save(['BackUp ' datestr(now,'mmmm_dd_yyyy HH_MM_SS') '.mat']);    disp('Program is finished in back up mode')    Alarm(['The back up is saved into ' pwd...          '\BackUp ' datestr(now,'mmmm_dd_yyyy HH_MM_SS') '.mat'], IsMute);    returnend;if ~soft_stop                                                              %Saving the result close(hwb);end;stat=[]; for Ch=1:Ch_Num   P_over_all=0.999; [E, CI]=Get_Stat_Func(Channels(Ch).Best',P_over_all); stat=[stat [E; CI].']; %Here P_over_all_stat is probability value for overall experiments statisticsendsave([path,CNLS_fit_Label,'.mat']);Alarm('Job done! Look for gifts under the tree =)',IsMute);                %Outputing audio and text messages%The road will be mastered by the one who walks it....